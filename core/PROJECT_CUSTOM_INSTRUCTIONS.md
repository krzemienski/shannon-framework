# Project-Specific Custom Instructions System

## Overview

Shannon Framework V5 introduces **project-specific custom instructions** that persist across sessions. These instructions capture project conventions, build commands, CLI argument defaults, and other project-specific context that should be adhered to in every session.

**Problem Solved**: Even when restoring context, agents forget project-specific conventions like "always run CLI with these arguments" or "build commands must use these flags."

**Solution**: Auto-generated custom instructions stored in `.shannon/custom_instructions.md`, loaded at every session start.

---

## Architecture

### File Location

```
project-root/
  .shannon/
    custom_instructions.md  ← Generated automatically
    sessions/                ← Checkpoint storage
    docs/                    ← Documentation
```

### Generation Triggers

Custom instructions are generated when:
1. **First time in project**: `/shannon:prime` detects no `.shannon/custom_instructions.md`
2. **User requests**: `/shannon:generate_instructions`
3. **Project changes**: Significant file count changes detected

### Loading Triggers

Custom instructions are loaded when:
1. **Every session start**: Via session_start hook or `/shannon:prime`
2. **After context restoration**: `/shannon:restore`
3. **Manual load**: `/shannon:load_instructions`

---

## Custom Instructions Format

### Structure

```markdown
# Custom Instructions for {project_name}

> Auto-generated by Shannon Framework
> Last updated: {timestamp}
> Project: {project_path}

## Project Identity

**Name**: {project_name}
**Type**: {project_type} (CLI tool, Web app, Library, etc.)
**Tech Stack**: {detected_stack}
**Entry Point**: {main_file}

---

## Build Commands

**Build**: `{build_command}`
**Test**: `{test_command}`
**Lint**: `{lint_command}`
**Format**: `{format_command}`
**Dev Server**: `{dev_command}`

---

## CLI Argument Defaults

{if CLI tool}
**Default Arguments**: `{default_args}`
**Required Flags**: `{required_flags}`
**Common Usage**: `{example_usage}`

**IMPORTANT**: ALWAYS use these arguments unless explicitly overridden:
```bash
{cli_command} {default_args} {rest_of_command}
```
{end if}

---

## Testing Conventions

**Test Framework**: {test_framework}
**Test Location**: {test_directory}
**Test Pattern**: {test_file_pattern}
**Coverage Requirement**: {coverage_threshold}%

**NO MOCKS**: Shannon enforces functional testing only
- Use real {database_type} instances
- Use real {api_type} endpoints
- Use Puppeteer for UI testing

---

## Code Conventions

**Style Guide**: {style_guide}
**Linter**: {linter}
**Formatter**: {formatter}
**Pre-commit Hooks**: {hooks_enabled}

**Formatting Before Commit**:
```bash
{format_command}
```

---

## Deployment Conventions

**Environment**: {deployment_env}
**Deploy Command**: `{deploy_command}`
**Pre-deploy Checks**: {pre_deploy_checks}

---

## Dependencies

**Package Manager**: {package_manager}
**Dependency File**: {dependency_file}
**Add Dependency**: `{add_dependency_command}`

---

## Project-Specific Rules

{for each custom_rule}
- **{rule_title}**: {rule_description}
{end for}

---

## Common Pitfalls

{for each pitfall}
❌ **{pitfall_title}**: {pitfall_description}
✅ **Correct Approach**: {correct_approach}
{end for}

---

## Session Restoration Notes

When restoring context:
1. Load these custom instructions FIRST
2. Then restore checkpoint
3. Verify custom rules still apply (project may have changed)

---

**Generated**: {timestamp}
**Valid Until**: Project structure changes significantly
**Regenerate**: `/shannon:generate_instructions --force`
```

---

## Generation Algorithm

### Step 1: Detect Project Type

```python
def detect_project_type(project_root):
    """Detect project type from file structure"""

    # Check for CLI indicators
    if exists("setup.py") or exists("pyproject.toml"):
        if has_console_scripts() or has_entry_points():
            return "CLI Tool"

    if exists("package.json"):
        if has_bin_field():
            return "CLI Tool"
        if has_scripts("start", "dev"):
            return "Web Application"
        return "JavaScript Library"

    if exists("Cargo.toml"):
        if has_bin_target():
            return "CLI Tool"
        return "Rust Library"

    # Default
    return "Application"
```

### Step 2: Extract Build Commands

```python
def extract_build_commands(project_root, project_type):
    """Extract build commands from project files"""

    if exists("package.json"):
        pkg = read_json("package.json")
        return {
            "build": pkg["scripts"].get("build", "npm run build"),
            "test": pkg["scripts"].get("test", "npm test"),
            "lint": pkg["scripts"].get("lint", "npm run lint"),
            "dev": pkg["scripts"].get("dev", "npm run dev")
        }

    if exists("pyproject.toml"):
        toml = read_toml("pyproject.toml")
        return {
            "test": "pytest",
            "lint": toml.get("tool.ruff.command", "ruff check ."),
            "format": "ruff format ."
        }

    if exists("Makefile"):
        return parse_makefile_targets()

    # Defaults
    return {}
```

### Step 3: Detect CLI Argument Patterns

```python
def detect_cli_patterns(project_root):
    """Detect common CLI argument patterns from usage"""

    # Read CLI entry point
    entry_point = find_cli_entry_point()

    # Parse argparse/click/typer configuration
    arg_parser = parse_cli_arguments(entry_point)

    # Extract patterns from recent git commits
    commit_commands = extract_commands_from_commits(limit=50)

    # Find most common argument combinations
    common_patterns = find_frequent_patterns(commit_commands)

    return {
        "default_args": most_common_pattern,
        "required_flags": extract_required_flags(arg_parser),
        "example_usage": generate_example_usage(common_patterns)
    }
```

### Step 4: Extract Testing Conventions

```python
def extract_testing_conventions(project_root):
    """Extract testing setup from project"""

    # Detect test framework
    if exists("pytest.ini") or has_dependency("pytest"):
        framework = "pytest"
    elif has_dependency("jest"):
        framework = "jest"
    else:
        framework = "unknown"

    # Find test directory
    test_dirs = ["tests", "test", "__tests__", "spec"]
    test_dir = next(d for d in test_dirs if exists(d))

    # Detect test pattern
    test_files = glob(f"{test_dir}/**/*.py") or glob(f"{test_dir}/**/*.test.js")
    pattern = infer_pattern(test_files)

    return {
        "framework": framework,
        "directory": test_dir,
        "pattern": pattern
    }
```

### Step 5: Detect Project-Specific Rules

```python
def detect_custom_rules(project_root):
    """Detect project-specific conventions"""

    rules = []

    # Check for .editorconfig
    if exists(".editorconfig"):
        rules.append({
            "title": "EditorConfig Enforcement",
            "description": "Use EditorConfig settings for all files"
        })

    # Check for pre-commit hooks
    if exists(".pre-commit-config.yaml"):
        rules.append({
            "title": "Pre-commit Hooks",
            "description": "All commits must pass pre-commit checks"
        })

    # Check for custom README rules
    if exists("CONTRIBUTING.md"):
        rules.extend(parse_contributing_rules())

    return rules
```

### Step 6: Identify Common Pitfalls

```python
def identify_pitfalls(project_root, project_history):
    """Identify common mistakes from git history"""

    pitfalls = []

    # Find reverted commits (common mistakes)
    reverted = find_reverted_commits()

    for revert in reverted:
        reason = extract_revert_reason(revert)
        pitfalls.append({
            "title": infer_pitfall_title(reason),
            "description": reason,
            "correct_approach": infer_correct_approach(revert)
        })

    # Add standard pitfalls for project type
    pitfalls.extend(get_standard_pitfalls(project_type))

    return pitfalls
```

### Step 7: Generate Instructions File

```python
def generate_instructions(project_root):
    """Generate complete custom instructions"""

    # Gather all information
    project_type = detect_project_type(project_root)
    build_commands = extract_build_commands(project_root, project_type)
    cli_patterns = detect_cli_patterns(project_root) if project_type == "CLI Tool" else None
    test_conventions = extract_testing_conventions(project_root)
    custom_rules = detect_custom_rules(project_root)
    pitfalls = identify_pitfalls(project_root)

    # Render template
    instructions = render_template(
        "custom_instructions.md.j2",
        project_name=os.path.basename(project_root),
        project_type=project_type,
        build_commands=build_commands,
        cli_patterns=cli_patterns,
        test_conventions=test_conventions,
        custom_rules=custom_rules,
        pitfalls=pitfalls,
        timestamp=datetime.now().isoformat()
    )

    # Write to .shannon/custom_instructions.md
    write_file(f"{project_root}/.shannon/custom_instructions.md", instructions)

    return instructions
```

---

## Loading Algorithm

### At Session Start

```python
def load_custom_instructions_at_session_start():
    """Load custom instructions during session initialization"""

    project_root = os.getcwd()
    instructions_path = f"{project_root}/.shannon/custom_instructions.md"

    if not exists(instructions_path):
        # First time in project - generate instructions
        print("Generating custom instructions for this project...")
        instructions = generate_instructions(project_root)
    else:
        # Load existing instructions
        instructions = read_file(instructions_path)

        # Check if stale (significant changes detected)
        if is_stale(instructions_path, project_root):
            print("Project changed significantly - regenerating instructions...")
            instructions = generate_instructions(project_root)

    # Display to agent
    print("\n<PROJECT_CUSTOM_INSTRUCTIONS>")
    print(instructions)
    print("\n</PROJECT_CUSTOM_INSTRUCTIONS>")

    return instructions
```

### Staleness Detection

```python
def is_stale(instructions_path, project_root):
    """Check if instructions are stale"""

    # Get last modification time
    last_modified = os.path.getmtime(instructions_path)

    # Check for significant changes since then
    changes = {
        "file_count_change": detect_file_count_change(last_modified),
        "dependency_changes": detect_dependency_changes(last_modified),
        "config_file_changes": detect_config_changes(last_modified)
    }

    # Stale if any significant change
    return any([
        changes["file_count_change"] > 10%,  # More than 10% file count change
        changes["dependency_changes"],        # Dependencies added/removed
        changes["config_file_changes"]        # Config files modified
    ])
```

---

## Integration with Shannon Commands

### /shannon:prime Integration

```bash
/shannon:prime

# Workflow:
# 1. Discover skills
# 2. Verify MCPs
# 3. **Load custom instructions** ← NEW
# 4. Restore context (if resume)
# 5. Activate forced reading
```

### /shannon:restore Integration

```bash
/shannon:restore --latest

# Workflow:
# 1. Restore checkpoint from Serena
# 2. **Reload custom instructions** ← Ensures fresh instructions
# 3. Resume work
```

### New Command: /shannon:generate_instructions

```bash
/shannon:generate_instructions [--force]

# Generate custom instructions for current project
# --force: Regenerate even if exists
```

---

## Example Custom Instructions

### Example 1: Python CLI Tool

```markdown
# Custom Instructions for shannon-cli

> Auto-generated by Shannon Framework
> Last updated: 2025-11-18T10:30:00Z
> Project: /Users/nick/projects/shannon-cli

## Project Identity

**Name**: shannon-cli
**Type**: CLI Tool
**Tech Stack**: Python 3.11, Click, Rich
**Entry Point**: cli.py

---

## Build Commands

**Test**: `pytest`
**Lint**: `ruff check .`
**Format**: `ruff format .`
**Install**: `pip install -e .`

---

## CLI Argument Defaults

**Default Arguments**: `--project-dir . --verbose`
**Required Flags**: `--project-dir`
**Common Usage**: `shannon --project-dir /path/to/project <command>`

**IMPORTANT**: ALWAYS use these arguments unless explicitly overridden:
```bash
shannon --project-dir . --verbose <rest_of_command>
```

---

## Testing Conventions

**Test Framework**: pytest
**Test Location**: tests/
**Test Pattern**: test_*.py
**Coverage Requirement**: 80%

**NO MOCKS**: Shannon enforces functional testing only
- Use real filesystem for file operations
- Use real subprocess for CLI testing
- Use temporary directories for isolated tests

---

## Code Conventions

**Style Guide**: PEP 8
**Linter**: ruff
**Formatter**: ruff format
**Pre-commit Hooks**: Enabled

**Formatting Before Commit**:
```bash
ruff format .
ruff check --fix .
```

---

## Project-Specific Rules

- **Always use absolute paths**: CLI internally converts relative to absolute
- **Verbose by default**: Users prefer seeing what's happening
- **Rich console output**: Use Rich for all user-facing output

---

## Common Pitfalls

❌ **Running CLI without --project-dir**: Defaults to cwd, may not be intended project
✅ **Correct Approach**: Always specify: `shannon --project-dir /path/to/project <command>`

❌ **Using print() for output**: Inconsistent formatting
✅ **Correct Approach**: Use Rich console: `console.print("[bold]Message[/bold]")`

---

**Generated**: 2025-11-18T10:30:00Z
**Valid Until**: Project structure changes significantly
**Regenerate**: `/shannon:generate_instructions --force`
```

### Example 2: React Web App

```markdown
# Custom Instructions for react-dashboard

> Auto-generated by Shannon Framework
> Last updated: 2025-11-18T11:00:00Z
> Project: /Users/nick/projects/react-dashboard

## Project Identity

**Name**: react-dashboard
**Type**: Web Application
**Tech Stack**: React 18, TypeScript, Vite, Tailwind CSS
**Entry Point**: src/main.tsx

---

## Build Commands

**Build**: `npm run build`
**Test**: `npm test`
**Lint**: `npm run lint`
**Format**: `npm run format`
**Dev Server**: `npm run dev`

---

## Testing Conventions

**Test Framework**: Vitest + React Testing Library
**Test Location**: src/**/*.test.tsx
**Test Pattern**: Component.test.tsx
**Coverage Requirement**: 70%

**NO MOCKS**: Shannon enforces functional testing only
- Use Puppeteer for E2E UI testing
- Use MSW for API mocking (server-level, not function mocks)
- Use real test database for data operations

---

## Code Conventions

**Style Guide**: Airbnb TypeScript
**Linter**: ESLint
**Formatter**: Prettier
**Pre-commit Hooks**: Enabled (lint-staged)

**Formatting Before Commit**:
```bash
npm run format
npm run lint --fix
```

---

## Project-Specific Rules

- **Tailwind for all styling**: No inline styles, no CSS files
- **Functional components only**: No class components
- **TypeScript strict mode**: All files must pass strict type checking

---

## Common Pitfalls

❌ **Using any type**: Defeats TypeScript purpose
✅ **Correct Approach**: Define proper types/interfaces

❌ **Inline styles**: Breaks Tailwind consistency
✅ **Correct Approach**: Use Tailwind classes: `className="bg-blue-500 text-white"`

---

**Generated**: 2025-11-18T11:00:00Z
**Valid Until**: Project structure changes significantly
**Regenerate**: `/shannon:generate_instructions --force`
```

---

## Benefits

1. **Persistent Context**: Custom instructions survive session restarts
2. **Auto-generated**: No manual configuration needed
3. **Project-aware**: Different projects get different instructions
4. **Stale Detection**: Automatically regenerates when project changes
5. **Seamless Integration**: Loaded at every session start

---

## Implementation Status

**Status**: Specification complete, ready for implementation

**Implementation Tasks**:
1. Create generation algorithm (`scripts/generate_custom_instructions.py`)
2. Create loading hook (`hooks/load_custom_instructions.py`)
3. Integrate with session_start.sh
4. Integrate with /shannon:prime
5. Integrate with /shannon:restore
6. Create /shannon:generate_instructions command
7. Add staleness detection
8. Test with various project types

---

**Version**: 5.0.0 (NEW in V5)
**Status**: Specification (implementation pending)
**Priority**: High (solves critical UX issue)

